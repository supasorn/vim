" Rule: echo 'yes'
" Rule: tmux send -t 1 'python main.py' Enter
"
" " Search pattern across repository files
function! FzfExplore(...)
    let inpath = substitute(a:1, "'", '', 'g')
    if inpath == "" || matchend(inpath, '/') == strlen(inpath)
      execute "cd" getcwd() . '/' . inpath
      let cwpath = getcwd() . '/'
      " call fzf#run(fzf#wrap(fzf#vim#with_preview({'source': 'ls -1pA && echo "../"', 'dir': cwpath, 'sink': 'FZFExplore', 'options': ['--prompt', cwpath, '--expect', 'ctrl-w']})))
      call fzf#run(fzf#wrap(fzf#vim#with_preview({'source': 'ls -1pA && echo "../"', 'dir': cwpath, 'sink': 'FZFExplore', 'options': ['--prompt', cwpath]})))
    else
      let file = getcwd() . '/' . inpath
      execute "e" file
    endif
endfunction

command! -nargs=* FZFExplore call FzfExplore(shellescape(<q-args>))

" function! TFile(dir)
"   if empty(a:dir)
"     let dir = getcwd()
"   else
"     let dir = a:dir
"   endif
"   let parentdir = fnamemodify(dir, ':h')
"   let spec = fzf#wrap(fzf#vim#with_preview({'options': ['--expect', 'ctrl-w'] }))

"   " hack to retain original sink used by fzf#vim#files
"   let origspec = copy(spec)

"   unlet spec.sinklist
"   unlet spec['sink*']
"   function spec.sinklist(lines) closure
"     if len(a:lines) < 2
"       return
"     endif
"     if a:lines[0] == 'ctrl-w'
"       call TFile(parentdir)
"     else
"       call origspec.sinklist(a:lines)
"     end
"   endfunction
"   call fzf#vim#files(dir, spec)
" endfunction

" command! -nargs=* TFile call TFile(<q-args>)


function! FirstLineCompile() 
  if !empty(matchstr(getline(1), ':'))
    let l:s = split(getline(1) , ':')
  else
    let l:s = ''
  endif
  if !empty(matchstr(l:s[0], 'Rule'))
    let l:command = l:s[1]
    write
    cd %:p:h
    let l:out = system(l:command)
    try
      cexpr l:out 
    catch
      "echo l:out
    endtry
    botright cwindow 8
  else
    execute ':SCCompileRun'
  endif
endfunction 

function! IterateRgMode()
  if !exists("g:rgmode")
   let g:rgmode = 0
 endif
 let g:rgmode = (g:rgmode + 1) % 4
 if g:rgmode == 0
   echo "Rg current buffer         [" . expand("%:p:h") . "]"
 elseif g:rgmode == 1
   echo "Rg current buffer depth 1 [" . expand("%:p:h") . "]"
 elseif g:rgmode == 2
   echo "Rg pwd                    [" . getcwd() . "]"
 else
   let path = system('cd '.shellescape(expand('%:p:h')).' && git rev-parse --show-toplevel 2> /dev/null')[:-2]
   echo "Rg git root               [" . path . "]"
 endif
endfunction

function! RgWithMode()
  if !exists("g:rgmode")
   let g:rgmode = 0
  endif

  if g:rgmode == 0
    call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ''", 1, fzf#vim#with_preview({'dir': expand("%:p:h")}), 0)
  elseif g:rgmode == 1
    call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case --max-depth=1 ''", 1, fzf#vim#with_preview({'dir': expand("%:p:h")}), 0)
  elseif g:rgmode == 2
    call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ''", 1, fzf#vim#with_preview({'dir': getcwd()}), 0)
  else
    call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ''", 1, fzf#vim#with_preview({'dir': system('cd '.shellescape(expand('%:p:h')).' && git rev-parse --show-toplevel 2> /dev/null')[:-2]}), 0)
  endif
endfunction

" command! -bang -nargs=* PRg
  " \ call fzf#vim#grep("rg -g '!tags' --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, fzf#vim#with_preview({'dir': getcwd()}), <bang>0)

function! JumpThroughParameter(direction)
  let flag = a:direction == 1 ? '' : 'b'
  let s1 = searchpos('\S(\S', 'en' . flag, line('.'))
  let s2 = searchpos(', \S', 'en' . flag, line('.'))
  if s1 != [0, 0] && (s2 == [0, 0] || 
        \ ((flag == '' && s1[1] < s2[1]) || (flag == 'b' && s1[1] > s2[1])) )
    call search('\S(\S', 'e' . flag, line('.'))
  else
    call search(', \S', 'e' . flag, line('.'))
  endif
endfunction

function! CopyWordUnderCursor()
  let @w = expand('<cword>')
endfunction

function! GrepCurrentDirectory(myParam)
  execute "Rg " . a:myParam . " %:p:h/*"
endfunction

function! DelTagOfFile(file)
  let fullpath = a:file
  let cwd = getcwd()
  let tagfilename = cwd . "/tags"
  let f = substitute(fullpath, cwd . "/", "", "")
  let f = escape(f, './')
  let cmd = 'sed -i "/' . f . '/d" "' . tagfilename . '"'
  let resp = system(cmd)
endfunction

function! UpdateTags()
  let f = expand("%:p")
  "let cwd = getcwd()
  let cwd = expand("%:p:h")
  let tagfilename = cwd . "/tags"
  let cmd = 'ctags -a -f ' . tagfilename . ' --c++-kinds=+p --fields=+iaS --extra=+q ' . '"' . f . '"'
  call DelTagOfFile(f)
  let resp = system(cmd)
endfunction

function! SCPSourceFile() 
  let dir = expand("%:p") 
  let ldir = "/Users/supasorn/Research/"
  let rdir = "/home/supasorn/research/"
  if match(dir, ldir) == 0
    let cmd = "scp " . expand("%:p") . " supasorn@174.21.163.107:" . substitute(expand("%:p"), ldir, rdir, "g")
    echo cmd
    let resp = system(cmd)
    echo resp
  endif
endfunction 

function! OpenRemoteOrLocal() 
  let dir = expand("%:p:h") 
  let ldir = "/home/supasorn/research/"
  let rdir = "/homes/grail/supasorn/research/"
  let scp = "scp://flatwhite.cs.washington.edu/"
  if match(dir, ldir) == 0
    let cmd = "e " . scp . substitute(expand("%:p"), ldir, rdir, "g")
    execute cmd
  elseif match(dir, "scp") == 0
    let cmd = "e " . substitute(substitute(expand("%:p"), scp, "", "g"), rdir, ldir, "g")
    execute cmd
  endif
endfunction 

function! FunctionObject()
  normal! f)%h
  let tail_pos = getpos('.')
  normal! B
  let head_pos = getpos('.')
  return ['v', head_pos, tail_pos]
endfunction 

function! AfterEquationObject()
  normal! $F=w
  let head_pos = getpos('.')
  normal! $
  let tail_pos = getpos('.')
  return ['v', head_pos, tail_pos]
endfunction 

function! BeforeEquationObject()
  normal! ^
  let head_pos = getpos('.')
  normal! f=be
  let tail_pos = getpos('.')
  return ['v', head_pos, tail_pos]
endfunction 

call textobj#user#plugin('function', {
\   'function': {
\     'select-i-function': 'FunctionObject',
\     'select-i': 'in',
\   },
\   'equation': {
\     'select-i-function': 'AfterEquationObject',
\     'select-i': '=',
\     'select-a-function': 'BeforeEquationObject',
\     'select-a': 'i=',
\   },
\ })




